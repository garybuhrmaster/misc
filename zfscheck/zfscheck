#!/bin/ksh
#
# zfscheck
#
# Check on the status of the zfs filesystems.  If there is a problem return
# a non zero exit code.  Depending on options, send email notification.  Loosly
# adopted from the script 'metacheck' that Sun made available for their Solaris
# Volume Manager product, Copyright (c) 1999 by Sun Microsystems, Inc.
#
# Options:
#
# -h
#   help
# -m recipient [recipient...]
#   Send email notification to the specified recipients.  This
#   must be the last argument. The notification shows up as a short 
#   email message with a subject of 
#        "ZFS Problem: zfscheck.who.nodename.poolname"
#   which summarizes the problem(s) and tells how to obtain detailed 
#   information. The "poolname" is the zfs pool name, "who" is from 
#   the -w option, and "nodename" is reported by uname(1).
#   Email notification is further affected by the following options:
#        -f   to suppress additional messages after a problem 
#             has been found. 
#        -d   to control the supression.
#        -w   to identify who generated the email.
#        -t   to force email even when there is no problem.
# -w who
#   indicate who is running the command. By default, this is the
#   user-name as reported by id(1M). This is used when sending
#   email notification (-m).
# -f 
#   Enable filtering.  Filtering applies to email notification (-m).
#   Filtering requires root permission.  When sending email notification
#   the file /etc/zfs/zfscheck.poolname.pending is used to 
#   control the filter.  The following matrix specifies the behavior
#   of the filter:
#
#   problem_found  file_exists    Behavior
#     yes            no           Create file, send notification
#     yes            yes          Resend notification if the current date 
#                                 (as specified by -d datefmt) is 
#                                 different than the file date.
#     no             yes          Delete file, send notification 
#                                 that the problem is resolved.
#     no             no           Send notification if -t specified.
#   
# -d datefmt
#   Specify the format of the date for filtering (-f).  This option 
#   controls the how often re-notification via email occurs. If the 
#   current date according to the specified format (strftime(3C)) is 
#   identical to the date contained in the 
#   /etc/zfs/zfscheck.poolname.pending file then the message is 
#   suppressed. The default date format is "%D", which will send one 
#   re-notification per day.
# -t
#   Test mode.  Enable email generation even when there is no problem.
#   Used for end-to-end verification of the mechanism and email addresses.
#   
#
# These options are designed to allow integration of zfscheck
# into crontab.  For example, a root crontab entry of:
#
# 0,15,30,45 * * * * /usr/sbin/zfscheck -f -w ZFScron \
#   -d '\%D \%h' -m notice@example.com 2148357243.8333033@pager.example.com
#
# would check for problems every 15 minutes, and generate an email to
# notice@example.com (and send to an email pager service) every hour when 
# there is a problem.  Note the \ prior to the '%' characters for a 
# crontab entry.  Bounced email would come back to root@nodename.
# The subject line for email generated by the above line would be
# ZFS Problem: zfscheck.ZFScron.nodename.poolname
#

# display a debug line to controlling terminal (works in pipes)
decho()
{
    if [ "$debug" = "yes" ] ; then
    echo "DEBUG: $*"    < /dev/null > /dev/tty 2>&1
    fi
}

#
# - MAIN
#
PATH=/sbin:/usr/sbin:/bin:/usr/bin
USAGE="usage: zfscheck [-h] [[-t] [-f [-d datefmt]] \
    [-w who] -m recipient [recipient...]]"

datefmt="%D"
debug="no"
filter="no"
mflag="no"
testarg="no"
pool=""
who=`/bin/id | /bin/sed -e 's/^uid=[0-9][0-9]*(//' -e 's/).*//'`

while getopts d:Dfmtw: flag
do
    case $flag in
    d)   datefmt=$OPTARG;
    ;;
    D)   debug="yes"
    ;;
    f)   filter="yes"
    ;;
    m)   mflag="yes"
    ;;
    t)   testarg="yes";
    ;;
    w)   who=$OPTARG;
    ;;
    \?)  echo $USAGE
    exit 1
    ;;
    esac
done

# if mflag specified then everything else part of recipient
shift `expr $OPTIND - 1`
if [ $mflag = "no" ] ; then
    if [ $# -ne 0 ] ; then 
    echo $USAGE
    exit 1
    fi
else
    if [ $# -eq 0 ] ; then 
    echo $USAGE
    exit 1
    fi
fi
recipients="$*"

curdate_filter=`/bin/date +$datefmt`
curdate=`/bin/date`
node=`/bin/uname -n`

#
# Check to see if zfs is even available on this system
#
if [ ! -x "/sbin/zpool" ] || [ ! -x "/sbin/zfs" ] || [ ! -d "/etc/zfs" ] ; then
    echo "zfscheck: zfs not available" 1>&2
    exit 1
fi

#
# Check to see if we have any pools to examine
#
/sbin/zpool list | /bin/grep "no pools available"               > /dev/null 2>&1
if [ $? -eq 0 ] ; then
    echo "zfscheck: no pools defined" 1>&2
    exit 1
fi

#
# Create a (semi?secure) directory for temp files
#
tmpdir=/tmp/zfscheck.$RANDOM.$RANDOM.$RANDOM.$RANDOM.$$
(umask 077 && mkdir $tmpdir) || ( echo "Could not create temporary directory! Exiting." 1>&2 ; exit 1 )

#
# establish files
#
zlist_f=$tmpdir/zpool_list.msg
zstat_f=$tmpdir/zpool_status.msg
msgs_f=$tmpdir/msgs
files="$zlist_f $zstat_f $msgs_f"
pending=0
retval=0

#
# clean up if interrupted
#
trap "rm -f $files > /dev/null 2>&1; rmdir $tmpdir > /dev/null 2>&1; exit 1" 1 2 3 15

#
# Get the list of pools
#
/sbin/zpool list -H                                             > $zlist_f  2>&1

# For each pool, check for status, and send any messages

while read pool size used avail capacity health altroot
do
   
    echo ""                                                     > $msgs_f   2>&1
    echo ""                                                     > $zstat_f  2>&1
    pending=0
    pending_f=/etc/zfs/zfscheck.$pool.pending
 
    # 
    # If the pool is not ONLINE, there is an error,
    # which may be expanded below, but at least insure
    # we mark it as an error (zpool status could fail).
    #
    if [ "$health" != "ONLINE" ] ; then
        echo "Pool $pool health is $health"                     > $msgs_f   2>&1
        echo "no additional information available"              >> $msgs_f  2>&1
        pending=1
        retval=1
    fi
    
    #
    # Get extended status
    #
    /sbin/zpool status $pool                                    > $zstat_f  2>&1

    #
    # Look for information in the status output that
    # indicates one (or more) warnings/errors
    #
    /usr/xpg4/bin/grep -E '|   see: |FAULTED|DEGRADED|UNKNOWN|OFFLINE|UNAVAIL|INUSE|currently in use|in use by pool' $zstat_f </dev/null >/dev/null 2>/dev/null
    if [ $? -eq 0 ] ; then
        pending=1
    fi
    /bin/grep "status: " $zstat_f </dev/null >/dev/null 2>/dev/null | /bin/grep -v "The pool is formatted using an older on-disk format" </dev/null >/dev/null 2>&1
    if [ $? -eq 0 ] ; then
        pending=1
    fi
    /bin/grep "action: " $zstat_f </dev/null >/dev/null 2>/dev/null | /bin/grep -v "Upgrade the pool" </dev/null >/dev/null 2>&1
    if [ $? -eq 0 ] ; then
        pending=1
    fi
    /bin/grep "errors: " $zstat_f </dev/null 2>&1 | /bin/grep -v "No known data errors" </dev/null >/dev/null 2>&1
    if [ $? -eq 0 ] ; then
        pending=1
    fi
    /bin/grep " state: " $zstat_f | /bin/grep -v "ONLINE"
    if [ $? -eq 0 ] ; then
        pending=1
    fi

    #
    # If any messages were created, report them.
    #
    if [ $pending -ne 0 ] ; then
        if [ -n "$recipients" ] ; then
            re=""
            if [ -f $pending_f ] && [ "$filter" = "yes" ] ; then
                re="Re: "
                # we have a pending notification, check date to see if we resend
                penddate_filter=`cat $pending_f | head -1`
                if [ "$curdate_filter" != "$penddate_filter" ] ; then
                    rm -f $pending_f                            > /dev/null 2>&1
                else
                    if [ "$debug" = "yes" ] ; then
                        echo "zfscheck: email problem notification still pending"
                        cat $pending_f
                    fi
                fi
            fi
            if [ ! -f $pending_f ] ; then
                if [ "$filter" = "yes" ] ; then
                    echo "$curdate_filter\n\tDate:$curdate\n\tTo:$recipients" \
                                                                > $pending_f
                fi
                echo "\
ZFS: $node: zfscheck: Report: $curdate"                         >> $msgs_f
                echo "\
--------------------------------------------------------------" >> $msgs_f
                cat $msgs_f $zstat_f | mailx -s \
                 "${re}ZFS Problem: zfscheck.$who.$node.$pool" $recipients
            fi
        else
           cat $msgs_f
           cat $zstat_f
        fi
    else
        # no problems detected,
        if [ -n "$recipients" ] ; then
            # default is to not send any mail, or print anything.
            echo "\
ZFS: $node: zfscheck: Report: $curdate"                         >> $msgs_f
            echo "\
--------------------------------------------------------------" >> $msgs_f
            if [ -f $pending_f ] && [ "$filter" = "yes" ] ; then
                # pending filter exists, remove it and send OK
                rm -f $pending_f                                > /dev/null 2>&1
                echo "Problem resolved"                         >> $msgs_f
                cat $msgs_f | mailx -s \
                 "Re: ZFS Problem: zfscheck.$who.$node.$pool" $recipients
            elif [ "$testarg" = "yes" ] ; then
                # for testing, send mail every time even though there is no problem
                echo "Messaging test, no problems detected"     >> $msgs_f
                cat $msgs_f | mailx -s \
                 "ZFS Problem: zfscheck.$who.$node.$pool" $recipients
            fi
        else
            echo "zfscheck: pool $pool okay"
        fi
    fi

done < $zlist_f

#
# Clean up and exit
#
rm -f $files                                                    > /dev/null 2>&1
rmdir $tmpdir                                                   > /dev/null 2>&1
exit $retval

